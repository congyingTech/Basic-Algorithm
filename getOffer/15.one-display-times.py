#encoding:utf-8
"""
问题描述：
输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。
例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。
解决方案：
总结规律：1位数，1-9中，1一共出现了1次；
        2位数，10-99中，10-19的十位上一共出现了10*1=10次，对于每个十位开头的数字10-19、20-29，每个数个位上出现的是1-9中1出现的次数，共有9个区间9*1=9次；
        3位数，100-999，100-199百位上出现了10**2=100次，对于每个百位数开头，例如100-199，200-299，低位上其实就是0-99这个区间上1出现的次数，一共9个区间 9*19=171次；
公式化 f(n)代表n位数包含1的个数：
f(1) = 1
f(2) = 9 * f(1) + 10 ** 1
f(3) = 9 * f(2) + 10 ** 2
f(n) = 9 * f(n-1) + 10 ** (n-1)
例如23456这个数，10000以前的总的1的个数就是f(5)
还要求10000-23456这个部分1的个数：
  我们首先把最高位单独拿出来分析一下，求出最高位上1的个数，如果最高位是1，则最高位上一共会出现的1的次数是低位上数字+1，例如12345，最高位上一共出现了2346个1；如果最高位大于1，则会一共出现的次数是10000-19999一共10**4个数。
  然后，根据最高位的不同，计算出该高位前面的相同位数范围中的所有数中1的个数。
  例如对于34567，需要计算出10000-19999，20000-29999中一的个数，这时候计算一的个数，也就是计算0-9999中1的个数，
  这就可以转化成上面的f(n)来计算了，调用上面函数可以直接得到，然后用得到的值和最高位和1的差值（这里最高位是3）相乘就可以了。

分析完上面的部分后，我们现在只剩下最高位后面的部分了，我们发现剩下的部分还是一个整数，例如23456剩下了3456，这时候直接使用递归处理剩下的3456就行了。
"""
class Solution(object):
    def oneDisplayTimes(self,n):
        if n < 10:
            return 1 if n >= 1 else 0
        # 把23456分为两部分，第一部分是20000， 第二部分是3456，可以用递归的思想，即去掉高位
        # 第一部分0～20000
        high_digit = self.get_digit(n) # 得到最高位的位数5
        #   20000分解为五位数10000～19999和5以下的低位数0～9999
        #   0～9999的次数可以用递归的方法解决
        low_sums = self.get_ones_by_digit(high_digit-1)  # 次高位4位数包含的1的个数,low_sums是0～9999包含的次数是get_ones_by_digit(4)
        high_digit_num = int(str(n)[0]) # 得到最高位的数
        # 第二部分3456，也是低位的次数
        low_nums = n - high_digit_num * 10 ** (high_digit-1)

        # 下面high_sums求解第一部分的10000～19999的次数, all_sums是求解10000～19999+20000～23456的次数
        if high_digit_num == 1:
            high_sums = low_nums + 1 # 最高位上1的个数，比如12345，1出现在万位10000～12345的次数是2345+1次
            all_sums = high_sums
        else:
            high_sums = 10**(high_digit-1) # 比如23456，1出现在万位的数值范围是10000～19999，次数是10**(5-1)
            all_sums = high_sums + low_sums * (high_digit - 1) # 
        
        # 总次数=0～9999的次数+（10000～19999的次数 + 20000～23456的次数）+ 低位3456的次数
        return low_sums+all_sums+self.oneDisplayTimes(low_nums)

    def get_ones_by_digit(self, digit):
        if digit == 0:
            return 0
        if digit == 1:
            return 1
        current = self.get_ones_by_digit(digit-1)*9 + 10**(digit-1)

        return current + self.get_ones_by_digit(digit-1)
    
    def get_digit(self, num):
        ret = 0
        while num:
            ret+=1
            num/=10
        return ret

if __name__ == "__main__":
    s = Solution()
    n = 23456
    print(s.oneDisplayTimes(n))